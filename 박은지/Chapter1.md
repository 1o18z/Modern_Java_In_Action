## 자바 8이 등장하기 이전

대부분의 자바 프로그램은 코어 중 하나만 사용했고, 멀티코어를 사용하기 위해선 스레드를 사용해야 했다  
→ 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점!  
- 자바 8에서는 **병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법**을 제공한다

&nbsp;  

## 자바 8

간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반으로 한다

- **스트림 API**
    - 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원
    - 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 synchronized(동기화)를 사용하지 않아도 된다
- **메서드에 코드를 전달하는 기법**
- **인터페이스와 디폴트 메서드**

&nbsp;

## 왜 아직도 자바는 변화하는가?

자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다

하지만 프로그래밍 언어 생태계가 변화하면서,

프로그래머는 빅데이터에 직면하며 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다

→ 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었다

&nbsp;

### 1️⃣ 스트림 처리

첫 번째 프로그래밍 개념 : 스트림 처리

- 스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- **스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 작업을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다**
    - 스트림 파이프라인을 이용해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수도 있다
- **스레드라는 복잡한 작업을 사용하지 않으면서도 병렬성을 얻을 수 있다**

### 2️⃣ 동작 파라미터화로 메서드에 코드 전달하기

두 번째 프로그래밍 개념 : 코드의 일부를 API로 전달

- 자바 8에서는 **메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공**한다
    - 이러한 기능을 이론적으로 **동작 파라미터화**라고 부른다  
  (18, 19장에서 동작 파라미터 활용 방법 설명)


### 3️⃣ 병렬성과 공유 가변 데이터

세 번째 프로그래밍 개념 : 병렬성을 공짜로 얻을 수 있다

- **스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다**
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행 하더라도 안전하게 실행될 수 있어야 하는데,   
이러한 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다
  - 공유된 변수나 객체가 있으면 병렬성에 문제가 발생한다
      - 물론 synchronized를 이용해 공유된 가변 데이터를 보호하는 규칙을 만들 수 있을 것이다
        (하지만 일반적으로 synchronized는 시스템 성능에 악영향을 미친다)
      - **자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다**

&nbsp;

## 자바 함수

자바 8에서는 함수를 새로운 값의 형식으로 추가했다

- 프로그래밍 언어의 핵심은 값을 바꾸는 것이고, 이 값을 일급 시민이라고 한다
- 프로그램을 실행하는 동안 모든 구조체를 자유롭게 전달할 수는 없다 -> 이급 시민
    - 메서드, 클래스 등
    - 클래스와 메서드는 그 자체로 값이 될 수 없다
        - 이들을 일급 시민으로 만들 수 있다면 프로그래밍에 유용하게 활용할 수 있다

&nbsp;

### 메서드와 람다를 일급 시민으로

- **메서드 참조**

    ```java
    File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    		public boolean accept(File file) {
    				return file.isHidden();
    		}
    });
    ```
  - File클래스에는 이미 isHidden이라는 메서드가 있는데 굳이 FileFilter로 isHidden을 감싼 다음에 FileFilter를 인스턴스화해야 할까?

   ```java
    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```
    - 기존에 객체 참조를 이용해 객체를 이리저리 주고받았던 것처럼 자바 8에서는 File::isHidden을 이용해서 메소드 참조를 만들어 전달할 수 있게 되었다

&nbsp;  

- **람다 : 익명 함수**
    - 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다

      (람다에 관한 내용은 3장에서 설명)


&nbsp;

### 메서드 전달에서 람다로

- 람다를 사용하면 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다
    - 하지만 람다가 복잡한 동작을 수행해 길어지면 익명 람다 보다는 메서드를 정의하고 메서드 참조를 활용하자


&nbsp;

## 스트림

- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다
    - 스트림 API를 이용하면 컬렉션 API와 다른 방식으로 데이터를 처리할 수 있다
        - 컬렉션에서는 반복 과정을 직접 처리했다 → 외부 반복

      (스트림API에 관해서는 4~7장에서 설명)

        - 스트림은 루프를 신경 쓸 필요 없이 라이브러리 내부에서 모든 데이터가 처리된다 → 내부 반복


&nbsp;


### 멀티스레딩은 어렵다

- 멀티스레딩 환경에서 스레드들은 동시에 공유된 데이터에 접근하고 갱신할 수 있다

  → 즉, 스레드를 잘 제어해야 한다

  (원치 않는 방식으로 데이터 변경 가능성 있음)

- 자바 8은 스트림API로 ‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’와 ‘멀티코어 활용 어려움’이라는 두 가지 문제를 모두 해결했다
    - 반복되는 패턴
        - 조건에 따라 데이터를 필터링, 추출, 그룹화하는 등의 기능이 있다

    - 멀티코어 활용
        - 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을, 다른 CPU는 뒷부분을 처리한 후 (**포킹 단계**), 하나의 CPU가 두 결과를 정리한다

- 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있다

(컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점)

- 순차 처리 방식 코드

    ```java
    List<Apple> heavyApples = inventory.stream()
                        .filter((Apple a) -> a.getWeight() > 150)
                        .collect(toList());
    ```


- 병렬 처리 방식 코드

    ```java
    List<Apple> heavyApples = inventory.parallelStream()
                        .filter((Apple a) -> a.getWeight() > 150)
                        .collect(toList());
    ```

&nbsp;


## 디폴트 메서드와 자바 모듈

- 디폴트 메서드로 기존 인터페이스의 변경의 어려움을 해결할 수 있다
- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다
    - 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함되기 때문에 디폴트 메서드라 부른다
- 디폴트 메서드를 통해 기존의 코드를 건드릴 필요 없이 인터페이스를 자유롭게 확장할 수 있다
    - 자바 8에서는 인터페이스 규격명세에 default라는 새로운 키워드를 지원한다

      (List에 직접 sort 메서드를 호출할 수 있는 이유도 디폴트 메서드 정의가 추가되었기 때문이다)


&nbsp;


## 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

### Optional

- Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다
    - NullPointer 예외를 피할 수 있도록 도와주는 클래스로, 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다

  (11장에서 자세히 설명)