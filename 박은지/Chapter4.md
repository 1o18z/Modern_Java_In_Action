# Chapter 4) 함수형 데이터 처리


많은 요소를 포함하는 컬렉션을 처리하려면?

→ 성능을 높이려면 멀티코어 아키텍처를 활용해 병렬로 컬렉션의 요소 처리

→ 하지만 병렬 처리 코드 구현은 단순 반복 처리 코드에 비해 복잡하고 어려움

→ 디버깅도 어려움

⇒ 스트림으로 시간 절약 + 편리함 겟

# 스트림이란 무엇인가?

**스트림?**

- 자바 8 API에 새로 추가된 기능
- 선언형으로 컬렉션 데이터 처리가 가능하다
    - = 데이터를 처리하는 임시 구현 코드 대신 질의로 표현할 수 있다
- 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리 가능하다

스트림을 이용한 칼로리를 기준으로 요리를 정렬

```java
List<String> lowCaloricDishesName = menu.stream().filter(d -> d.getCalories < 400).sorted(comparing(Dish::getCalories)).map(Dish::getName).collect(toList());
```

위 stream()을 parallelStream()으로 바꾸면 병렬로 실행 가능

```java
List<String> lowCaloricDishesName = menu.parallelStream().filter(d -> d.getCalories < 400).sorted(comparing(Dish::getCalories)).map(Dish::getName).collect(toList());
```

(parallelStream()을 사용했을 때의 스레드 사용, 성능 등에 대해서는 7장에서 설명)

- 선언형으로 코드 구현이 가능하다
    - 루프와 if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요 없이 ‘저칼로리의 요리만 선택하라’ 같은 동작의 수행 지정 가능
    - 선언형 코드와 동작 파라미터를 활용하면 변하는 요구사항에 쉽게 대응 가능하다
- 여러 빌딩 블록 연산(filter, map , ...)을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다
    - 가독성과 명확성 유지
- 고수준 빌딩 블록으로 특정 스레딩 모델에 제한 없이 자유롭게 어떤 상황에서든 사용 가능
    - 내부적으로 단일 스레드 모델에 사용할 수 있지만 멀티코어 아키텍처를 최대한 투명하게 활용 가능

**⇒ 즉, 스트림 API 덕에 데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정하라 필요가 없다**

```java
선언형 : 더 간결하고 가독성 굿
조립 가능 : 유연성 굿
병렬화 : 성능 굿
```

&nbsp;  
&nbsp;

# 스트림 시작하기

스트림 : 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

- **연속된** **요소**
    - 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스 제공 (컬렉션과 공통점)
    - filter, sorted, map처럼 표현 계산식이 주를 이룬다 (컬렉션은 시공간의 복잡성과 관련된 요소 저장/접근 연산이 주를 이룬다)
    - 컬렉션 주제 → 데이터, 스트림 주제 → 계산
- **소스**
    - 컬렉션, 배열, 입출력 자원 등의 데이터 제공 소스로부터 데이터를 소비
    - 정렬된 컬렉션으로 스트림을 생성하면 정렬 유지
        - 리스트로 스트림 만들면? 스트림의 요소는 리스트의 요소와 같은 순서 유지
- **데이터 처리 연산**
    - 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원

  (filter, map, reduce, find, match, sort 등으로 데이터 조작 가능)

  → 순차적/병렬로 실행 가능

  &nbsp;
- **파이프라이닝**
    - 파이프라인 구성을 위해 **스트림 자신을 반환**
        - 게으름, 쇼트서킷 같은 최적화 굿

      (연산 파이프라인은 데이터 소스에 적용하는 데이터베이스 질의와 비슷)

- **내부 반복**
    - 반복자를 이용해 명시적으로 반복하는 컬렉션과의 차이

&nbsp;  
&nbsp;  
# 스트림과 컬렉션

연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스 제공

- 연속된? → 순차적으로 값에 접근

## 예시

DVD에 어떤 영화가 저장되어 있을 경우

- DVD에 전체 자료구조가 저장되어 있으므로 DVD는 컬렉션

인터넷 스트리밍으로 같은 비디오를 시청할 경우

- 사용자가 시청하는 부분의 몇 프레임을 미리 내려받음
    - 스트림의 다른 대부분의 값을 처리하지 않은 상태에서 미리 내려받은 프레임부터 재생 가능
- 비디오 재생기에는 모든 프레임을 메모리에 컬렉션으로 저장할 수 있는 충분한 메모리가 없을 수도 있고, 있어도 모든 프레임을 내려받은 다음에 재생을 시작하기까지 아주 오랜 시간이 걸릴 수도 있다

&nbsp;

### 데이터를 언제 계산하느냐

컬렉션과 스트림의 가장 큰 차이

- **컬렉션**
    - 현재 자료구조가 포함하는 **모든 값을 메모리에 저장하는 자료구조**
    - ⇒ **컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다**
        - 컬렉션에 요소를 추가/삭제 가능한데, 이런 연산을 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계산되어야 한다
    - **적극적 생성** (= 모든 값을 계산할 때까지 기다린다)

  (생산자 중심 : 팔기도 전에 창고를 가득 채움)

- **스트림**
    - **요청할 때만 요소를 계산하는 고정된 자료구조**
    - 스트림에 요소를 추가/삭제 불가
    - 사용자가 요청하는 값만 스트림에서 추출한다는 것이 핵심

  (사용자 입장에서는 알 수 X)

    - ⇒ 스트림은 생산자와 소비자 관계를 형성
    - **게으른 생성 (= 필요할 때만 값을 계산한다)**
    - **딱 한 번만 탐색**
        - 탐색된 스트림의 요소는 소비된다
        - 다시 탐색 하려면? → 초기 데이터 소스에서 새로운 스트림을 만들어야 한다
            - 컬렉션처럼 반복 사용할 수 있는 데이터 소스여야 한다

            ```java
            List<String> title = Arrays.asList("Java8", "In", "Action");
            Stream<String> s = title.stream();
            s.forEach(System.out::println);
            s.forEach(System.out::println);
            // 이미 3번째 줄에서 스트림이 소비되었거나 닫히기 때문에 에러 발생
            ```

          → 데이터 소스가 I/O 채널이라면 소스를 반복 사용 불가하므로 새로운 스트림을 만들 수 없다

&nbsp;  
&nbsp;


# 외부 반복과 내부 반복

- **컬렉션**
    - 사용자가 직접 요소를 반복해야 한다 (for-each)
    - **⇒ 외부 반복**

```java
List<String> names = new ArrayList<>();
for(Dish dish: menu) {  
		names.add(dish.getName());
}
```

- **스트림**
    - 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해준다
    - **⇒ 내부 반복**
    - 함수에 어떤 작업을 수행할 지만 정하면 알아서 처리

```java
List<String> names = menu.stream().map(Dish::getName).collect(toList());
```

→ 파이프라인 실행. 반복자는 필요X

&nbsp;  

### 그래서 내부 반복을 이용하면

- 작업을 투명하게 병렬로 처리 가능
- 더 최적화된 다양한 순서로 처리 가능
    - 컬렉션으로 외부 반복으로 처리 한다면 이와 같은 최적화를 달성하기 어려움
- 스트림의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택
    - for-each를 이용한 외부 반복에서는 병렬성을 스스로 관리해야 함

⇒ 반복 과정을 우리가 신경쓰지 않아도 된다

- 단, 반복을 숨겨주는 연산 리스트(filter, map 등)가 미리 정의되어 있어야 한다
- 반복을 숨겨주는 대부분의 연산은 람다 표현식을 인수로 받으므로 동작 파라미터화 활용 가능

&nbsp;  
&nbsp;

# 스트림 연산

```java
List<String> names = menu.stream()
	.filter(dish -> dish.getCalories() > 300) // 중간연산
	.map(Dish::getName) // 중간연산
	.limit(3) // 중간연산
	.collect(toList()); // 스트림을 리스트로 변환
```

### 중간 연산

- 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다 (= 게으르다)
    - 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문

  | 연산 | 형식 | 반환 형식 | 연산의 인수 | 함수 디스크립터 |
      | --- | --- | --- | --- | --- |
  | filter | 중간 연산 | Stream<T> | Predicate<T> | T → boolean |
  | map | 중간 연산 | Stream<R> | Function<T, R> | T → R |
  | limit | 중간 연산 | Stream<T> |  |  |
  | sorted | 중간 연산 | Stream<T> | Comparator<T> | (T, T) → int |
  | distinct | 중간 연산 | Stream<T> |  |  |

&nbsp;  

### 최종 연산

- 스트림 파이프라인에서 결과를 도출한다
    - List, Integer, void 등 스트림 이외의 결과가 반환된다

  | 연산 | 형식 | 반환 형식 | 목적 |
      | --- | --- | --- | --- |
  | forEach | 최종 연산 | void | 스트림의 각 요소를 소비하면서 람다를 적용한다 |
  | count | 최종 연산 | long(generic) | 스트림의 요소 개수를 반환한다 |
  | collect | 최종 연산 |  | 스트림을 소비해서 리스트, 맵, 정수 형식의 커렉션을 만든다 |

&nbsp;  

## 스트림 이용하기

- 질의를 수행할 (컬렉션 같은) 데이터 소스
- 스트림 파이프라인을 구성할 중간 연산 연결
- 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

&nbsp;  
&nbsp;  

# 마치며

- 스트림 : 소스에서 추출된 연속된 요소. 데이터 처리 연산 지원
- 스트림은 내부 반복 지원. filter, map, sorted 등의 연산으로 반복 추상화
- 중간 연산과 최종 연산
- 중간 연산 : filter, map처럼 스트림을 반환하면서 다른 연산과 연결
    - 파이프라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성 불가
- 최종 연산 : forEach나 count처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산
- 스트림의 요소는 요청할 때 게으르게 계산됨
