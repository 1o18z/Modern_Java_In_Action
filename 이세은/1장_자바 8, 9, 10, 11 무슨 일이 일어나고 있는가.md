# 1장_자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## 1.1 역사의 흐름

96년에 자바 개발 키트(JDK 1.0)이 발표된 이후 자바는 많은 사람들에게 적극적으로 활용되었다. 이후 새로운 기능과 더불어 계속 발전했다.

**자바 역사를 통틀어 가장 큰 변화는 자바 8에서 일어났다.**

### 자바 8의 요구사항

- 자바 8은 더 간단한 방식으로 코드를 구현해야 한다.

사과 목록을 무게 순으로 정렬하는 자바 8 이전 코드

```java
Collections.sort(inventory, new Comparator<Apple>() {
	public int compare(Apple a1, Apple a2) {
		return a1.getWeight().compareTo(a2.getWeight());
	}
});
```

자바 8 이용 시 자연어에 더 가까운 방식으로 코드구현이 가능하다.

```java
inventory.sort(comparing(Apple::getWeight));
```

- 자바 8은 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공해야 한다.
    
    자바 8 이전에는 멀티코어를 활용하기 위해서 스레드를 사용하고 발전하면서 병렬실행 환경을 위한 진화가 계속 되었다(스레드, 락, 스레드 풀 등). 하지만 개발자가 활용하기 쉽지 않았다.
    
    자바 8에서는 멀티코어 CPU 대중화와 같은 하드웨어 변화에 맞춰 병렬실행을 단순화 해준다.
    
<br>

### 요구사항에 따른 제공 기술

- 스트림 API
    
    데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림 API를 제공한다.
    
    고수준 언어로 원하는 동작을 표현하면 최적의 저수준 실행 방법을 선택한다.
    
- 메서드에 코드를 전달하는 기법
    
    간결하게 동적 파라미터화를 구현할 수 있다.
    
    함수형 프로그래밍에서 위력을 발휘한다.

- 인터페이스의 디폴트 메서드

<br>

---

## 1.2 왜 아직도 자바는 변화하는가

### 자바의 흐름

- 코드를 JVM 바이트 코드로 컴파일하는 특징과 모든 브라우저에서 가상 머신 코드 지원
- JVM이 업데이트 되면서 경쟁언어들이 JVM에서 부드럽게 실행되고 자바와 상호동작할 수 있게됨
- 임베디드 컴퓨팅 분야로 확장중
- 자바 8에서 병렬 프로세싱을 위해 멀티코어 병렬성을 강화
- 외부의 컴포넌트나 외부 벤더의 컴포넌트를 이용한 개발사례가 증가하면서 자바 8이후부터는 디폴트 메서드와 모듈 제공

### 자바8 설계의 밑바탕

- **스트림 처리**
    
    유닉스에서 여러 명령을 병렬로 처리하는 것처럼 스트림 API는 파이프라인을 만드는데 필요한 메서드를 제공한다.
    
    [java.util.stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html) 패키지의 스트림 API
    
    Stream<T> → T형식으로 구성된 일련의 항목
    
    일련의 스트림으로 만들어 처리하고, 스트림 파이프라인으로 입력부분을 여러 CPU 코어에 쉽게 할당


    
- **동작 파라미터화로 메서드에 코드 전달하기**
    
    자바 8이전에는 메서드에 따른 동작이 정해져 있었다.
    
    자바 8에서는 메서드를 다른 메서드의 파라미터로 넣어줄 수 있음으로 동작자체를 파라미터화 할 수 있다.
    
    ex) 고객ID를 비교하는 메서드인 compareUsingCustomerId()의 동작을
    정렬을 수행하는 sort()의 파라미터로 넣어주기
    
    동작 파라미터화 기능으로 스트림 API가 사용된다!
    

- **병렬성과 공유 가변 데이터**
    
    스트림 메서드로 전달하는 코드 동작 방식은 기존과 조금 달라진다.
    
    다른 코드와 동시에 실행되더라도 안전한 실행을 하기 위해서는 **공유된 가변 데이터**에 접근하지 않아야 한다.
    
    synchronized로 공유 가변 데이터를 보호하는 규칙을 만들 수 있겠지만 자바 8 스트림으로 기존 자바 스레드보다 쉽게 병렬성을 활용할 수 있다.
    
    공유되지 않은 가변 데이터 메서드와 동작 파라미터 기능을 함수형 프로그래밍 패러다임의 핵심사항이다.
    
    cf. 명령형 프로그래밍은 정해진 기능만 수행
    

자바는 값을 변화시키는데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍을 도입했다.

---

## 1.3 자바 함수

자바의 함수는 수학적인 함수와 같이 단순히 정해진 기능이 적용되는 함수를 의미한다.

**자바 8에서는 함수를 값처럼 취급한다.**

“값”을 바꾸기 위해 프로그래밍 언어를 사용하면서 우리가 바꿀 수 있는 여러가지 값들을 일급값이라고 하고 메서드와 클래스와 같은 구조체가 값의 구조를 표현했다.

프로그램이 실행되면서 자유롭게 전달할 수 없는 구조체는 이급값으로 그 자체로 값이 될 수 없다.

자바 9에서는 메서드(구조체, 이급값)를 일급값으로 바꿀 수 있게 하여 프로그래밍의 효율성을 가져왔다.

- **메서드와 람다를 일급시민으로**
    
    **왜 메서드를 값으로 취급하는 것이 프로그래밍을 더 쉽게 할까?**
    
    1. 메서드 참조로 더욱 명시적인 프로그램을 짤 수 있다.
      
       디렉토리에서 숨겨진 파일을 모두 필터링 하는 코드
    
    ```java
        File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
              public boolean accept(File file){
                  return file.isHidden();
              }
          });
    ```

    File 클래스에 이미 isHidden메서드가 있음에도 불구하고 여러번 감싼 후 FileFilter를 인스턴스화 한다.
    
    위 코드에 자바 8 적용시키기 

    ```java
      File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```
    
    File클래스의 isHidden메서드를 값으로 사용해서 직접 전달
    
  2. 람다를 포함해서 이용할 수 있는 편리한 클래스나 메서드가 없을 때 간결한 프로그래밍이 가능하다.
    
       ```java
       (int x) -> x + 1
       ```
    

- **코드 넘겨주기**
    
    메서드 중 대부분이 중복되는 코드에서 극히 일부분만 다르다면 전체를 중복으로 구현할 필요없다.
    
    중복되는 부분을 공통적으로 처리한 후 다른 부분만 각 메소드를 파라미터로 넣어주어 프로그래밍한다.
    
    ```java
    isGreenApple(Apple){...} //사과 색이 초록색인지 판별하는 메서드
    isHeavyApple(Apple){...} //사과 무게가 특정무게 이상인지 판별하는 메서드
    
    public interface Predicate<T>{
    	boolean test(T t);
    }
    
    static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p){
    	List<Apple> result = new ArrayList<>();
    	for(Apple apple: inventory){
    		if(p.test(apple)){
    			result.add(apple);
    		}
    	}
    	return result;
    }
    ```
    
    Predicate 함수 → 파라미터를 받아 boolean값을 반환하는 함수
    
    다음과 같이 메서드를 호출한다.
    
    ```java
    filterApples(inventory, Apple::isGreenApple);
    filterApples(inventory, Apple::isHeavyApple);
    ```
    
- 메서드 전달 → 람다
    
    익명함수인 람다로 간단한 작성이 가능하다.
    
    ```java
    //filterApples(inventory, Apple::isGreenApple);
    filterApples(inventory, (Apple a) -> Green.equals(a.getColor()) );
    ```
    
    라이브러리 메서드인 filter를 이용하면 수작업으로 메서드 구현할 필요없음
    
    병렬성 문제로 자바 8에서는 filter와 비슷한 동작을 하며 연산집합을 포함하는 새로운 스트림 API제공
    

---

## 1.4 스트림

자바 어플리케이션에서 컬렉션이 많이 이용되지만 모든 문제를 해결해주지는 못했다.

스트림은 기존 컬렉션의 많은 기본 코드들을 간결하게 해준다.

컬렉션 API는 외부반복으로 각 요소를 반복하면서 작업을 해주는데 비해 스트림 API는 내부반복으로 라이브러리 내부에서 모든 데이터가 한번에 처리된다.

스트림 API 또한 데이터의 수가 많을 경우 성능이슈? or 추상적인 코드이기 때문에 직관적인 코드확인의 어려움?

- 멀티스레딩
    
    자바 8이전의 스레드 API로 멀티스레딩을 구현하는 것은 쉽지 않았다.
    
    각각의 스레드는 공유된 데이터에 동시에 접근하고 각 스레드를 잘못 제어할 경우 데이터가 잘못 변경될 수 있다.
    
    스트림 API는 데이터를 연산하는 방법에 대한 패턴을 제공한다.
    
    데이터 필터링, 추출, 그룹화, 각 CPU에 처리를 맡기는 포킹 등
    
    큰 스트림을 작은 스트림으로 나누어서 처리함으로써 병렬로 처리하는 효과, 서로 상호작용 하지 않는 메서드에 대해서 가변 공유 객체를 이용해서 병렬로 처리하는 효과를 가진다.
    

---

## 1.5 디폴트 메서드와 자바 모듈

자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.

default 키워드를 사용해서 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다.

프로그램의 확장성을 위해 디폴트 메서드는 중요하다.

ex) List 인터페이스의 sort메소드는 default로 정의되어 모든 클래스가 구현하지 않아도 된다.

- **다중 상속?**
    
    하나의 클래스에서 여러개의 인터페이스 구현한다면 같은 시그니처를 가지는 디폴트 메소드가 존재 할 수도 있음.. 각 인터페이스의 디폴트 메서드명이 같은 경우?
    
    ```java
    public interface a{
    	default void hello(){...}
    }
    
    public interface b{
    	default void hello(){...}
    }
    
    public Class c implements a, b{
    	//hello()메서드 사용방법..?
    }
    ```
    

---

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

- NullPointer 예외를 피하기 위한 Optional<T>클래스
    - null이 될 수 있는 값을 wrapper클래스로 감싸기
- 구조적 패턴 매칭