# 4장_스트림_소개

스트림의 필요성

자바에서는 컬렉션으로 데이터를 그룹화하고 처리할 수 있다.

하지만 컬렉션을 처리할 때 구현해줘야 하는 부분이 많다.

데이터베이스 쿼리는

```sql
SELECT name FROM dishes WHERE calorie < 400
```

처럼 우리가 원하는 것을 추가적인 작업없이 적어주어도 결과를 얻을 수 있고 그 사이의 구현 기술을 몰라도 된다.

많은 요소를 포함하는 컬렉션, 멀티코어 아키텍처로 병렬로 처리해야 하지만 구현이 복잡하다.

사용자가 컬렉션을 사용하면서 이해하기 쉬운 직관적인 구현을 할 수 있도록 해주는 것이 스트림이다.

---

## 4.1 스트림

스트림은 자바 8에 새로 추가되었다.

데이터를 처리하기 위한 구현코드를 따로 만드는 것이 아닌 데이터를 직접 가지고 쿼리를 적용시켜서 컬렉션 데이터를 처리할 수 있다.

멀티스레드 코드를 구현하지 않아도 스트림으로 투명하게 병렬로 처리가 가능하다.

- 저칼로리 요리이름을 반환하고 칼로리순으로 정렬하는 코드에 스트림 적용하기

<자바 8 이전의 기존 코드>

저칼로리인 요리를 선형탐색하면서 필터링된 리스트(lowCaloricDishes)

리스트를 칼로리순으로 오름차순 정렬(Collection.Sort())

정렬된 리스트 안의 요리의 이름을 가지는 리스트(lowCaloricDishesName)

여기서  lowCaloricDishes 결괏값을 담기만 하는 역할을 한다. 이런 변수를 가비지 변수라고 한다.

자바 8에서는 이런 가비지 변수 없이 라이브러리 내에서 모두 처리 가능하다.

<자바 8 스트림 적용 코드>

```java
import static java.util.Comparator.comparing;
import static java.util.stream.Collections.toList;
List<String> lowCaloricDishesName =
						menu.stream()
								.filter(d -> d.getCalories() < 400)
								.stored(comparing(Dish::getCalories))
								.map(Dish::getName)
								.collect(toList());
```

칼로리가400이 넘지 않는 요리들을 정렬하고 해당 요리의 이름들을 저장한 리스트 menu

만약 병렬로 실행하기 위해서 멀티코어 아키텍처를 활용한다면

```java
List<String> lowCaloricDishesName =
						menu.parallelStream()
								.filter(d -> d.getCalories() < 400)
								.stored(comparing(Dish::getCalories))
								.map(Dish::getName)
								.collect(toList());
```

stream()을 parallelStream()으로만 변경해주면 된다.

cf. parallelStream가 언제나 나은 선택일까?

아니다. 작업을 분할하고 다시 병합하는 비용, 컨텍스트 스위칭같은 것도 생각해주어야 하기 때문에 병렬수행을 하기 위해서 데이터들의 참조 지역성이나 여러가지 테스트를 고려해야 한다.

### 스트림의 이점

**선언형, 조립가능, 병렬화**

- 선언형으로 코드를 작성할 수 있다.
    
    선언형 코드와 동작 파라미터화를 사용한다. 복붙이 아닌 람다 이용
    
- 복잡한 데이터처리 파이프라인을 만들 수 있다.
    
    여러 연산을 파이프라인으로 구성해서 가독성이 높고 명시적이다.
    
    filter은 고수준 빌딩 블록으로 이루어져 있어서 특정 스레드 모델에 제한되지 않는다.
    
    내부적으로 단일 스레드 모델뿐만 아니라 멀티코어 아키텍처를 투명하게 사용가능 하다.
    
    →병렬화 하면서 스레드나 락을 걱정할 필요가 없어짐
    

스트림은 Map의 내부 타입에 따라 클래스의 인스턴스를 그룹화할 수 있다.

Dish클래스 안의 type 상수필드의 값 종류중 FISH인 것들, MEAT인 것들 등등으로 내부 데이터에 따라 그룹으로 데이터 추출이 가능하다.

cf. 선언형으로 컬렉션으로 제어할 수 있도록 만들어진 라이브러리들

구아바, 아파치, 람다제이

---

## 4.2 스트림 시작하기

[java.util.stream.Stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html) 인터페이스

스트림은 **데이터 처리연산**을 지원하도록 **소스**에서 추출한 **연속된 요소**

연속된 요소 → 컬렉션은 접근과 저장 연산을 가진다. 스트림으로 주어진 계산을 하는 것뿐만 아니라연속된 값 집합의 인터페이스를 제공한다.

소스 → 여러가지 데이터 제공해주는 자원으로부터 데이터를 직접 사용한다. 정렬된컬렉션(리스트)에 스트림을 생성하면 정렬이 그대로 유지된다.

데이터 처리 연산 → 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다. 각 연산은 순차적으로나 병렬로 실행할 수 있다.

### 스트림 특징

- 파이프라이닝
    
    스트림 연산끼리 연결할 수 있다. 게으름, 쇼트서킷같은 최적화 가능
    
- 내부 반복
    
    반복자를 외부적으로 생성해서 자료구조를 사용하는 컬렉션과 달리 내부 반복을 한다.
    

이전의 예제에서 스트림 분석

```java
menu.stream() //menu : 데이터소스, 연속된 요소를 스트림에 제공
		.filter(d -> d.getCalories() < 400) // filter : 칼로리로 필터링 한 요리 선택
		.map(Dish::getName) // map : 요리를 요리명으로 바꾸고 반환
		.limit(3) // limit : 스트림 크기 축소
		.collect(toList()); // collect : 스트림을 다른 형식으로 변환
```

collect 제외하고 나머지 연산은 서로 파이프라인 형성할 수 있도록 stream 반환

collect를 호출하기 전까지 출력되는 것 없이 리스트 스트림에 대한 일종의 질의 반복

질의를 반복하면서 메서드호출이 저장이 된다. 

---

## 4.3 스트림과 컬렉션

컬렉션과 스트림은 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.

임의로 데이터에 접근하는 것이 아닌 순차적으로 접근한다.

컬렉션과 스트림의 큰 차이는 데이터를 계산하는 타이밍이다.

컬렉션은 자료구조가 포함하는 모든 값을 메모리에 저장해야 한다. 컬렉션에 추가하려는 데이터들은 추가 전에 계산되어야 한다. 데이터를 모두 담아야 하므로 그에 맞게 자료구조가 가변적으로 변해야 한다.

1. 컬렉션 연산 수행 시작!
2. 데이터 계산(연산을 적용할 요소를 추가 또는 삭제 가능)
3. 데이터를 컬렉션에 추가
4. 2,3을 모든 요소에 대해 반복
5. 컬렉션 연산 끝!

스트림은 요청할 때만 데이터를 계산한다. 전체 데이터를 담을 정도의 크기는 필요없고 적정한 크기로 자료구조가 고정적이다.

이런 특성은 스트리밍과 같은 무제한의 데이터 수가 들어올 때의 프로그래밍에 도움을 준다.

사용자가 요청할 때만 데이터를 계산한다.

다른 예로 인터넷 검색이 있다. 검색어를 입력했을 때 모든 검색 결과를 받을 때까지 기다리지 않아도 가장 비슷한 몇개의 요소만을 스트림을 얻는다. 다음 결과를 알고 싶다면 사용자의 요청을 받은 후 생산자가 요청을 받은 만큼 또 리턴해준다.

### 스트림 특징

- 딱 한번만 탐색 가능하다
    
    탐색된 스트림 요소는 소비된다. 다시 탐색하려면 새로운 스트림을 생성해야 한다. (반복 사용할 수 있는 데이터 소스라면 가능, IO는 불가)
    
- 외부반복과 내부반복
    
    외부반복인 컬렉션은 사용자가 직접 반복자를 사용해서 요소를 반복한다. for each
    
    내부반복인 스트림은 알아서 반복을 처리하고 그에 대한 스트림값을 어딘가에 저장한다.
    
    작업을 투명하게 병렬로 처리하고 더 최적화시켜서 다양한 순서로 처리가 가능하다. 특히 병렬로 처리할 때 병렬에 관한 설정을 자동으로 선택해준다.
    
    내부 반복과정을 위해서 연산 리스트를 미리 정의해주어야 한다.filter, map 필터링과 자료구조 연산
    
    Dish클래스의 요소를 하나씩 읽으면서 300이상의 요리라면 해당 요리의 이름을 저장하는 로직을 짠다면
    
    외부반복이 아닌 스트림질의로 간단하게 만들수 있다
    
    ```java
    List<String> highCaloricDish = menu.stream()
    		.filter(dish -> dish.getCalories() > 300)
    		.map(Dish::getName)
    		.collect(tolist());
    ```
    

---

## 4.4 스트림 연산

스트림 인터페이스는 많은 연산을 지원한다.

연결할 수 있는 중간연산(filter, map, limit 등)과 스트림을 닫는 최종연산(collect 등)으로 나뉜다.

### 중간 연산

중간 연산은 최종연산을 파이프라인테 실행하기 전까지 아무 연산을 수행하지 않는다.

나중에 처리시작..중간연산은 하나로 쭉 합쳐지고 마지막에 최종연산으로 한번에 처리된다.

filter, map, limit, collect 순이고 중간 연산의 람다에 출력문을 포함한다면 limit연산은 **쇼트서킷**이라는 기법으로 limit로 주어진 크기의 스트림이 생성되고 filter와 map은 **루프 퓨전**이라는 깁한 과정으로 병합된다. 

### 최종 연산

스트림 외의 결과가 반환된다.

menu.stream().forEach(System.out::println); //menu에서 만든 모든 요리 출력, void반환

### 스트림 이용

데이터 소스 - 중간연산 - 최종연산

스트림의 파이프라인은 빌더 패턴(호출을 연결해서 설정생성, 마지막에 설정에 따라서 build()호출)과 유사

---

질문

스트림을 중간변수로만 이루어지게 하고 변수화할 수 있을까?

```java
Stream<String> filteredStream = myList.stream()
    .filter(s -> s.length() <= 4)
    .sorted()
    .limit(3);

List<String> result = filteredStream.collect(Collectors.toList());
```