# 3장_람다_표현식_#1

자바 8의 새로운 기능 람다 표현식

익명 클래스 ≠ 람다 표현식

이름 없는 함수이면서 메서드를 인수로 전달할 수 있으므로 비슷하지만 같지 않다.

## 3.1 람다란 무엇인가

### 특징

- 익명 → 메서드와 달이 이름이 없다.
- 함수 → 클래스에 종속되는 메서드가 아닌 함수라고 한다. 하지만 메서드 요소인 파라미터 리스트, 바디, 반환 형식, 예외 리스트를 포함한다.
- 전달 → 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 가능하다.
- 간결성 → 익명 클래스보다 코드가 줄어든다.

### 람다 구조

```java
(Apple a1, Apple a2) -> a1.getWeight().compare(a2.getWeight());
() -> 42
(String s) -> s.length()
```

람다 파라미터 → 메서드에서의 파라미터

화살표 → 람다의 파라미터 리스트와 바디를 구분한다.

람다 바디 → 람다 반환값

## 3.2 어디에, 어떻게 람다를 사용할까?

### 함수형 인터페이스

함수형 인터페이스는 추상 메서드가 오직 하나다.

람다를 사용하면 함수형 인터페이스의 추상 메서드 구현을 인스턴스로 직접 전달할 수 있다.

따라서 전체 표현식을 함수형 인터페이스의 인스턴스로 취급 가능하다.

```java
public static void process(Runnable r){
	r.run();
}
process(() -> System.out.println("..."));

//람다를 사용해주는 레벨을 다르게 해줄 수 있음
Runnable r1 = () -> System.out.println("...");
process(r1);
```

함수형 인터페이스인 Runnable의 인스턴스로 표현식을 전달한다.

### 함수 디스크립터

**함수형 인터페이스의 추상 메서드 시그니처와 람다 표현식의 시그니처는 같다.**

함수 디스크립터는 시그니처를 서술하는 메서드이다.

(Apple, Apple) → int, () → void

<br>

cf. 바디 부분에서 한개의 void 메서드를 호출할 경우 중괄호 필요없음(단순 출력)

<br>

자바에서는 함수형 인터페이스의 역할 명시하고 사용하기 위해서 어노테이션을 지원한다.

@FunctionalInterface

추상 메서드가 한개 이상이라면 컴파일 에러 발생

## 3.3 람다 활용 : 실행 어라운드 패턴

자원 처리에 사용하는 순환 패턴 → 자원 열기 - 자원 처리 - 자원 닫기

자원 설정과 정리 코드가 실제 처리 코드를 감싼다.

람다를 활용해서 설정, 정리 과정을 재사용하자.

### 람다 + 동작파라미터화

1단계 : 변화될 수 있는 처리부분을 유연하게 파라미터화 한다.

메서드 동작을 파라미터화 하고 그 파라미터를 람다로 작성한다.

```java
//두줄 출력하는 코드
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

2단계 : 만든 람다 시그니처를 가지는 함수형 인터페이스를 생성한다.

만든 인터페이스를 인수의 파라미터로 전달 가능하다.

```java
@FunctionalInterface
publid interface BufferedReaderProcessor {
	String process (BufferedReader b) throws IOException;
}
```

3단계 : 동작 실행

람다로 추상 메서드 구현을 직접 전달하고 자원 처리는 전달되는 것에 따라 다르게 이루어진다.

전달된 코드는 함수형 인터페이스의 인스턴스로 전달된 코드와 같은 방식으로 호출할 수 있다.

```java
public String processFile(BufferedReaderProcessor p) throws IOException {
 ...
return p.process(BufferedReader객체); //바디 내에서 함수형 인터페이스 메서드 접근 가능
}
```

4단계 : 람다 전달

람다 표현식을 메서드의 파라미터로 넣어주어 사용한다.

```java
String oneLine = processFile((BufferedReader br) -> br.readLine());
```

## 3.4 함수형 인터페이스 사용

람다 표현식을 사용하려면 함수 디스크립터 기술하는 함수형 인터페이스 집합이 필요하다.

[java.util.function](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html) 패키지 함수형 인터페이스 제공

### Predicate

불리언 표현식이 필요한 상황에서 따로 정의 없이 빠른 사용이 가능하다.

객체를 판별하는 test 추상 메서드

(T) → boolean

### Consumer

T형식의 객체를 인수로 받아서 특정 동작을 수행하고 싶을 때 사용한다.

특정 동작 수행시키는 accept 추상 메서드

(T) → void

### Function

입력을 출력으로 매핑하는 람다를 정의할 때 사용할 수 있다.

제네릭 받아서 제네릭 리턴하는 apply 추상 메서드

(T) → R

<br>

제네릭 내부 구현 때문에 제네릭 파라미터에는 참조형만 사용 가능

따라서 기본형을 참조형으로 바꿀 수 있는 기능을 제공한다.

기본형 → 참조형(박싱 boxing)

참조형 → 기본형(언박싱 unboxing)

박싱, 언박싱이 자동으로 이루어지게 할 수도 있다.(오토박싱)

여러가지 함수형 인터페이스로 특정형식을 입력받고 다양하게 출력할 수 있다.

() → new apple(10) : Supplier<T> 객체 생성 등등

<br>

예외를 던지는 람다를 만드려면 함수형 인터페이스에 정의하거나 try catch문으로 감싸야 한다.

## 3.5 형식 검사, 형식 추론, 제약

지금까지 궁금했던 것 → 람다가 함수형 인터페이스를 어떻게 구현할까?

람다 표현식 자체에는 구현에 관련된 코드가 명시되어있지 않다.

람다의 실제 형식으로 파악해볼 수 있다.

### 형식 검사

람다가 사용되는 컨텍스트를 보고 형식을 추론할 수 있다(파라미터나 변수 타입).

- 대상 형식 → 람다 표현식의 형식
- 형식 확인 과정(람다 컨텍스트 확인)
    1. 람다가 사용된 메서드의 정의 확인
    2. 람다가 사용된 메서드의 파라미터 부분의 형식과 대상 형식 확인
    3. 함수형 인터페이스 확인
    4. 함수형 인터페이스 내 메서드 디스크립터 확인
    5. 돌아와서 메서드의 파라미터의 타입이 적절한지 확인

### 같은 람다, 다른 함수형 인터페이스

같은 디스크립터를 가지는 추상 메서드들이 있다.

Callable과 PrivilegedAction은 둘다 () → T

<br>

cf. 다이아몬드 연산자. List<String> listOfStrings = new ArrayList<>();

컨텍스트에 의해 형식이 추론된다.

<br>

cf. 람다 바디에 일반 출력문이 있으면 void를 반환하는 함수 디스크립터와 호환된다. 파라미터도 호환될 경우 각 함수형 인터페이스의 메서드의 형식과 달라도 유효한 코드?

```java
Predicate<String> p = s -> list.add(s);
```

Predicate의 test메서드는 boolean을 반환하지만 람다 표현식에서 일반 표현식을 사용했기 때문에 사실 상 인수를 전달한 것이 아닌 단순 코드 실행…

결국 p는 boolean타입을 반환하기는 하지만 틀린 코드는 아닌 것?

저런 코드는 어디에서 사용되는지. 코드가 실행되었는지 확인하기 위해서 사용되는지

<br>

같은 디스크립트 형 함수형 인터페이스  메서드를 사용할 때 명시적으로 캐스트 가능

execute((Action)) () -> {});

### 형식 추론

자바 컴파일러는 대상형식을 이용해 함수형 인터페이스를 추론해서 메서드 디스크립터를 알아낸다.

람다와 함수형 인터페이스의 메서드는 디스크립터가 같다.

따라서 컴파일러는 함수 시그니처를 안다면 람다 시그니처도 추론 가능하다.

결국 람다 파라미터 형식에 접근 가능하므로 우리는 람다 문법에서 생략해도 된다.

상황에 따라 명시하거나 배제

(Apple a1) → a1.getWeight() //형식 추론X

(a1) → aq.getWeight() //형식 추론O

### 지역변수 사용

- **람다 캡처링(capturing lambda)**
    
    람다는 익명함수처럼 자유변수를 활용할 수 있다.(외부에서 정의된 변수)
    
    인스턴스 변수와 정적 변수 자유럽게 캡처할 수 있지만
    
    final이 명시되어있거나 실질적으로 그렇게 사용되어야 한다.
    
    한번 할당 가능한 final변수들을 캡처할 수 있는 것이다.
    

**왜 final이 선언된 변수만 사용가능한지? (지역 변수 제약)**

인스턴스 변수→ 힙에 저장

지역 변수 → 스택에 저장

람다가 지역함수로 바로 접근 가능하다면 스레드에서 람다가 실행된다면 **변수를 할당한 스레드**가 사라져서 변수 할당이 해제되어도 **람다를 실행중인 스레드**에서 접근하려 할 수도 있다.

따라서 자바에서는 변수에 접근할 때 변수 자체에 접근허용하는 것이 아닌 변수 복사본을 제공한다. 복사본은 원본이 아니기 때문에 값이 변경되면 안된다. 따라서 지역변수에는 값을 처음에 한번만 할당하는 제약이 생긴 것이다.

또한 지역 변수 제약은 외부 변수를 변화시키는 코드에 있어서 제동을 걸 수 있다.

cf. 클로저

- 클로저(Closure)
    
    함수의 비지역 변수를 자유럽게 참조할 수 있는 함수 인스턴스
    
    클로저는 다른 함수의 인수로 전달될 수도 있고 클로저 외부에 정의된 변수의 값에 접근하고 값 변경도 가능하다. 자바 8의 익명클래스와 람다는 비슷한 동작을 수행한다.
    
    차이점은 클로저와 다르게 람다가 정의된 메서드의 지역 변수의 값을 변경할 수 없다. 지역 변수값은 final이어야 한다.
    
    자동으로 람다는 변수가 아닌값에 국한되어 동작한다는 것이 명확해진다.
    
    지역변수값은 스택에 있어서 자기를 정의한 스레드와 같이 생존한다.
    
    가변 지역 변수를 새로운 스레드에서 캡쳐가 가능하다면 안전하지 않다.